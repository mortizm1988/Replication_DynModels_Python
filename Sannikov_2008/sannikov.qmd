---
title: "Replication: Dynamic Contracting in Continuous Time"
date: last-modified
date-format: long
author:
  - name: Marcelo Ortiz M.
    affiliations:
      name: Universitat Pompeu Fabra
format:
  html: 
    toc: true
    toc-location: left
    link-external-icon: true
    link-external-newwindow: true
    smooth-scroll: true
    html-math-method: katex
    code-fold: true
    code-summary: "Show the code"
    fig-width: 8
    fig-height: 6
    df-print: paged

embed-resources: true
execute:
  echo: true
  warning: false
  message: false
  error: false

---

# State Variable

The agent's **continuation value**  $W_t$ evolves according to:

$$
dW_t = r(W_t - u(C_t) + h(A_t)) dt + r \, y(W_t) \, (dX_t - A_t dt)
$$

where:

-  $C_t$  is the agent's consumption,
-  $A_t$ is the agent's effort,
-  $X_t$ is the **stochastic output process**, following:

$$
dX_t = A_t dt + \sigma dB_t
$$

with Brownian motion $B_t$ and volatility $\sigma$.


# Principal's Hamilton-Jacobi-Bellman  Equation

The HJB equation for the principal's profit function $F(W)$ is:
$$
r F(W) = \max_{a > 0, c} \left\{ r(a - c) + F'(W) r(W - u(c) + h(a)) + \frac{1}{2} F''(W) r^2 \gamma(a)^2 \sigma^2 \right\}
$$

where:

$$
dX_t = A_t dt + \sigma dB_t
$$

- $r(a - c)$ is the **instantaneous profit flow** of the principal,
- $F'(W) r(W - u(c) + h(a))$ accounts for how the agent’s continuation value changes due to effort and consumption,
- $\frac{1}{2} F''(W) r^2 \gamma(a)^2 \sigma^2$ captures the impact of volatility in the contract.

## Parameter values  and Functional forms

- $r = 0.1$ is the **discount rate**,
- $\sigma = 1.0$ is the **volatility of output process**,
- $u(C) = \sqrt{C}$ is the agent's **utility function**, 
- $h(A) = 0.5 A^2 + 0.4 A$ is the **effort cost function**.

## Optimal Effort and Consumption
### Consumption:
Since the principal chooses $c(W)$ to maximize the right-hand side of the HJB equation, we take the derivative of the RHS of the HJB with respect to  $c$:

$$
\frac{\partial}{\partial c} \left[ r(a - c) + F'(W) r(W - u(c) + h(a)) \right] = 0
$$

obtaining the first-order condition:

$$
F'(W) u'(c) = 1
$$

Since the agent’s utility function is:

$$
u(c) = \sqrt{c}
$$

its derivative is:

$$
u'(c) = \frac{1}{2\sqrt{c}}
$$

Substituting  into the first-order condition:

$$
F'(W) \cdot \frac{1}{2\sqrt{c}} = 1
$$

Solving for  $c_{opt}$  yields:

$$
c_{\text{opt}}(W) = \left( \frac{1}{-2F'(W)} \right)^2
$$

### Effort:

In Sannikov’s approach the contract is set up so that the agent’s incentive compatibility constraint is satisfied “locally” via a martingale representation of his continuation value. In effect, the contract is designed so that the agent’s choice of effort appears only in the drift. This implies that the agent’s optimal effort is determined by the first-order condition (holding the chosen optimal consumption rule $c_{\text{opt}}(W))$ fixed:

$$
\frac{\partial}{\partial a} \left[ r(a - c) + F'(W) r(W - u(c) + h(a)) \right] = 0
$$
obtaining
$$
r+rF'(W)h'(a)=0
$$
which implies that the optimal effort is:
$$
F'(W) h'(a) = -1 
$$

subtituting the effort cost function $h(a) = 0.5 a^2 + 0.4 a$ and its derivative $h'(a) = a + 0.4$ we get:
$$
a_{\text{opt}}(W) = \max \left\{ \frac{1}{-F'(W)} - 0.4, 0 \right\}
$$


##  Profits from retiring the agent
$$F_0(u(c))=-c$$

(notice that the profits will be zero, $dW_t=U_t$.)

## **Boundary Conditions & Smooth Pasting**

The function $F(W)$ must satisfy the following conditions:

1. **Lower boundary condition** (zero profit at zero continuation value):
   $$
   F(0) = 0
   $$

2. **Retirement boundary condition** (termination value function):
   $$
   F(W_{gp})=F_0(\text{Inv}(u(W_{gp})))=F_0(W_{gp})= -W_{gp}^2
   $$

3. **Smooth pasting condition** (ensuring differentiability at retirement):
   $$
   F'(W_{gp}) = -2 W_{gp}
   $$



For computation purposes we rewrite the HJB equation as:
$$
F''(W) = \min_{a > 0, c} \frac{F(W) - a + c - F'(W)(W - u(c) + h(a))}{r \gamma (a)^2 \sigma^2 / 2}
$$


# Code

```{python}
import numpy as np
from numpy.typing import NDArray
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from scipy.integrate import solve_ivp
from scipy.optimize import root_scalar

# -------------------------------
# Parameters and functional forms
# -------------------------------
r = 0.1      # discount rate
sigma = 1.0  # volatility

def u(c: float)->float:
    """Agent's utility function."""
    return np.sqrt(c)

def h(a: float)->float:
    """Effort cost function."""
    return 0.5*a**2 + 0.4*a

def h_prime(a: float)->float:
    """Derivative of h (and equals gamma(a))."""
    return a + 0.4

# -------------------------------------------------
# Optimal controls computed from the first-order conditions
# -------------------------------------------------
def c_optimal_func(F_prime: float) -> float:
    """
    c_opt(W) = (-F'(W)/2)**2.
    """
    # if F_prime >= 0:
    #    return 0
    return ((-F_prime)/2)**2

def a_optimal_func(F_prime: float) -> float:
    """Optimal effort from -F'(W)*h'(a)=1 with h'(a)=a+0.4.
       Hence, a_opt = max{1/(-F') - 0.4, 0}.
    """
    return max(1/(-F_prime) - 0.4,0)

# ------------------------------
# ODE: the HJB written as a second order ODE in F
# ------------------------------
def F_ode(W: float, Y: NDArray[np.float64]) -> NDArray[np.float64]:
    """
    Y[0] = F(W),  Y[1] = F'(W).
    Computes F''(W) from the rearranged HJB equation:
    
    F''(W) = 2 * [F(W) - a + c - F'(W)*(W - u(c) + h(a))]
             ---------------------------------------------
                    r * sigma^2 * (h'(a))^2
    """
    F_val, F_prime = Y
    # Compute optimal controls (assume F_prime < 0)
    c = c_optimal_func(F_prime)
    a = a_optimal_func(F_prime)
    gamma = h_prime(a)
    drift = W - u(c) + h(a)
    F_double_prime = 2*(F_val - a + c - F_prime*drift) / (r * sigma**2 * (gamma**2))
    return [F_prime, F_double_prime]


def solve_for_F(fprime_guess,return_sol=False):
    """
    Given a candidate for Fprime(0), integrate the ODE frontward
    from 0 to a fix value=2 using the boundary conditions at retirement:
    F(0)=0,  F(W_gp) = -W_gp^2,    F'(W_gp) = -2*W_gp.
    The first step, for each Fprime(0),  find W_gp, by finding the first case where  F'(W_gp) = -2*W_gp.
    The second step is to find the Fprime(0) such that its W_gp associated meet the condition F(W_gp) = -W_gp^2
    """
    w_grid = np.linspace(0, 1.5, 100)       
    sol = solve_ivp(fun=F_ode, t_span= [0,1.5], y0= [0, fprime_guess],
                    t_eval=w_grid, method='RK45', atol=1e-16) # "Lower Boundary Condition" is in y0[0]=0, meaning F(0)=0.
    
    # Smooth-Pasting Condition: select the first sol.t (=W) where F'(W_gp) = -2*W_gp
    idx = np.argmin(np.abs(sol.y[1] + 2*sol.t))
    W_gp = sol.t[idx]
    # Retirement (Upper) Boundary Condition: compute a loss function for the condition F_Wgp = -W_gp**2
    F0_val = sol.y[0][idx] + W_gp**2

    if return_sol:
        return sol, W_gp
    return F0_val

#  function find the root of the loss function
res = root_scalar(solve_for_F,  method='newton',x0=0.1,xtol=1e-16)

# solve the ODE with the optimal Fprime(0)
sol, W_gp = solve_for_F(res.root,return_sol=True)
F_W= sol.y[0]
W_vals = sol.t

c_optimal_array = np.vectorize(c_optimal_func)
a_optimal_array = np.vectorize(a_optimal_func)
c_vals = c_optimal_array(sol.y[1])
a_vals = a_optimal_array(sol.y[1])
drift_vals = W_vals - np.sqrt(c_vals) + (0.5*a_vals**2 + 0.4*a_vals)  # i.e. W - u(c) + h(a)
F0=-W_vals**2


# Create a figure with two columns, left is wide, right is narrower
fig = plt.figure(figsize=(8, 6))
gs = gridspec.GridSpec(nrows=1, ncols=2, width_ratios=[2.5, 1])

# --- LEFT PLOT (Profit) ---
ax_left = fig.add_subplot(gs[0])
ax_left.plot(W_vals, F_W, label='F(W)')
ax_left.plot(W_vals, F0, label='F₀(W)')
ax_left.axvline(W_gp, color='red', ls='--', label='W_gp')
ax_left.set_xlabel('W')
ax_left.set_ylabel('Profit')
ax_left.legend()
ax_left.set_title('Principal’s Profit')

# --- RIGHT COLUMN: three stacked plots ---
gs_right = gridspec.GridSpecFromSubplotSpec(3, 1, subplot_spec=gs[1],
                                            hspace=0.4)

# Effort subplot
ax_eff = fig.add_subplot(gs_right[0])
ax_eff.plot(W_vals, a_vals)
ax_eff.set_ylabel('Effort a(W)')
ax_eff.axvline(W_gp, color='red', ls='--')
ax_eff.set_ylim([0, 1])  # adjust if you want

# Consumption subplot
ax_cons = fig.add_subplot(gs_right[1])
ax_cons.plot(W_vals, c_vals)
ax_cons.set_ylabel('Consumption c(W)')
ax_cons.axvline(W_gp, color='red', ls='--')
ax_cons.set_ylim([0, 1])  # adjust as needed

# Drift subplot
ax_dr = fig.add_subplot(gs_right[2])
ax_dr.plot(W_vals, drift_vals)
ax_dr.set_ylabel('Drift of W')
ax_dr.set_xlabel('W')
ax_dr.axvline(W_gp, color='red', ls='--')

plt.tight_layout()
plt.show()
```
